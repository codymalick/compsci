\documentclass[10pt,letterpaper,onecolumn,draftclsnofoot]{IEEEtran}
\usepackage[margin=0.75in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}
\usepackage{tabu}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=C,
columns=flexible,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=4
}

\begin{document}
  \begin{titlepage}
    \title{CS 444 - Spring 2016 - Writing Assignment 4}
    \author{Cody Malick\\
    \texttt{malickc@oregonstate.edu}}
    \date{May 23, 2016}
    \maketitle
    \vspace{4cm}
    \begin{abstract}
      \noindent Understanding how an operating system handles memory is key
      to understanding the overall flow of data through an OS. In this report,
      we will cover how Linux, Windows, and FreeBSD handle this important job
      in their respective kernels, and contrast them.
    \end{abstract}
  \end{titlepage}

  \tableofcontents
  \clearpage
  \section{Introduction}
  Memory management is the bedrock of any operating system used in the real
  world. Memory allows processes near instant access to the data storage they
  need, and in large quantities! How operating systems handle memory is a simple
  concept, but are expanded on differently by different operating systems. In 
  this report, we will look at how different operating systems handle the
  cornerstone that is memory management, and compare them to each other. 
  
 % Actually write an introduction, including why the reader should care
  \section{Linux}
	Linux handles memory in fairly straightforward, simplistic way. It
	starts out with pages. Pages are the simplest unit of memory in the OS.
	The kernel is actually unable to address any unit of measurement smaller
	than a page. The kernel also divides the sum total of pages into zones.
	Finally, we'll talk about the slab layer, allowing easy allocation of
	large amounts of data.
  \subsection{Pages}
  	Pages are the simplest and smallest addressable unit of memory usable
	by the kernel. The size of the page is dependant on the architecture
	the OS is running on. If it is a thirty-two bit system, the size of the
	page is usually four kilobytes, while a sixty-four bit system usually
	has a size of eight kilobytes. \cite{robertlove2010}

	It's important to point out that the kernel does not directly manage the
	physical pages on the hardware. This is left to the MMU (memory
	management unit). The kernel's job is to communicate with the MMU in
	sizes it understands (pages), and work together with the hardware to
	get the job done. 

	The page struct is very short, and simple. This is important because it
	is used constantly, and you don't want a large structure you have to 
	pass around constantly. \cite{robertlove2010}

	\begin{lstlisting}
		struct page {
			unsigned long	flags;
			atomic_t	_count;
			atomic_t	_mapcount;
			unsigned long	private;
			struct address_space	*mapping;
			pgoff_t		index;
			struct list_head	lru;
			void 		*virtual;
		};
	\end{lstlisting}
	
	We will briefly go over what the important fields in the struct do.
	First is the \texttt{flags} field. This field simply describes the
	status of the page. This includes describing if the page is locked or
	dirty (memory that may need to written to disk). \texttt{\_count}
	stores the number of references using a given page. When the count is
	greater than negative one, then the page is still being used, and should
	not be reused. The caching mechanism in Linux uses the \texttt{private},
	\texttt{mapping} variables to use the page as a caching point. The
	\texttt{private} variable indicates that the memory pointed to is private,
	and the \texttt{mapping} variable holds an address space being used by
	the page cache. Lastly, \texttt{virtual} holds the virtual address that
	points at the physical page. This field is particularlly important to
	users, as it enables easy and quick use of the memory space.

	Now that we know how Linux handles its basic memory unit, lets look at
	how it classifies these into zones. 
  \subsection{Zones}
	Linux uses zones to divide memory pages into subsections in order to
	deal with specific hardware limitations. Specifically, some hardware
	devices can only directly access certain physical memory, and some 
	operating systems can map more memory than they actually have. This is
	called virtual memory. There are four primary zones in Linux:
	\begin{description}
		\item \texttt{ZONE\_DMA}: Memory that is directly accessed by
			hardware, bypassing the MMU. 
		\item \texttt{ZONE\_DMA32}: The same as \texttt{ZONE\_DMA} but
			restricts direct memory access to 32-bit devices. 
		\item \texttt{ZONE\_NORMAL}: This contains the standard size
			page, with standard mapping. Should not allow DMA. This
			is where general use memory lives.
		\item \texttt{ZONE\_HIGHMEM}: Contains memory wich is not 
			permanently mapped to the kernel's address space.
	\end{description}
	\cite{robertlove2010}
	Next up is the slab layer, which allows the quick and simple allocation
	and deallocation of memory for data structures. 
  \subsection{Slabs}
	Linux has a slab layer that facilitates a very important function: the
	quick and easy allocation and deallocation of memory for data
	structures. The slab layer maintains someting called a \textit{free list}.
	The job of the free list is to hold memory that's already been allocated
	for the purpose of quickly allocate a data structure's memory. This is
	done for data structures that are frequently used, and provides a nice
	performance increase. Essentially, the slab layer caches data structures.
	\cite{robertlove2010}
	
	Know all of this, next is examining how exactly all this wonderful
	infrastructure is used, with basic allocation and deallocation of memory.

   \subsection{Basic Allocation and Deallocation}
	\subsubsection{Allocation}
	Allocation is the bedrock of using memory. If you couldn't put something
	there, it would be useless! Here are the basics of allocating memory in
	Linux. At the simplest level, Linux provides the \texttt{alloc\_pages()}
	function. This function allows you to allocate two to the nth power pages,
	where \texttt{order} is a parameter of \texttt{alloc\_pages}. Here is an
	the actual prototype of the \texttt{alloc\_pages} function:
	\begin{lstlisting}
		struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
	\end{lstlisting}
	\texttt{gfp\_t gfp\_mask} is a flag that is needed to get pages from memory.
	\texttt{gfp} stands for \texttt{\_\_get\_free\_pages()}, and the different
	flag types allow for allocation of memory in specific ways.\cite{robertlove2010}
	\texttt{order} is simply the number of pages we want allocated as a power
	of two.

	Although it is a useful function, as users, we more often want to obtain
	memory in terms of bytes. We can do this in the kernel by using the
	\texttt{kmalloc()} function. This function is simliar to \texttt{malloc()},
	but it has a flags parameter that is identical to the \texttt{gfp\_t gfp}
	flag from \texttt{alloc\_pages}. \texttt{kmalloc} is very useful if we
	know the exact size of the structure we are allocating for using the C
	function \texttt{sizeof()}. 

	\subsubsection{Deallocation}
	Deallocation is equally as important as allocation. We need to be able
	to free the space we allocated in order to reuse it! Here are some basic
	deallocation functions that are used in Linux. To directly free a page,
	you can use any of the following functions:
	\begin{lstlisting}
		void __free_pages(struct page *page, unsigned int order)
		void free_pages(unsigned long addr, unsigned int order)
		void free_page(unsigned long addr)
	\end{lstlisting}
	Any of these functions would free the pages allocated with \texttt{alloc\_pages()}.

	The counterpart to \texttt{kmalloc()} is \texttt{kfree()}. You can pass
	in the object that you have given memory to, and the \texttt{kfree()} function
	will return that piece of memory back to the pool of available memory.

	Linux keeps things fairly straightforward and easy to understand in its
	memory management layer. Next, we will examine how Windows and FreeBSD
	implement the same interfaces to handle	memory.
  \section{Windows}
  \subsection{}
  \subsection{}
  \section{FreeBSD}
  FreeBSD often shares very simliar implementations with Linux. In terms of memory
  management, it is still the case. Memory allocation and deallocation are comperable. 
  \subsection{Pages}
  At the bottom of FreeBSD, we still have pages. Pages are the smallest addressable
  unit usable by the FreeBSD kernel. And again, FreeBSD interacts and works with the 
  onbaord MMU to manage memory. 
  \subsection{Memory Allocation and Deallocation}
  FreeBSD implements a general use memory manager interface simliar to the C 
  functions \texttt{malloc()} and 
  \texttt{free()} functions to help manage its memory. Specifically requesting 
  a certain number of pages does not seem to be a feature of the FreeBSD kernel.
  Linux also uses simliar implementations that are almost identical to \texttt{malloc}.
  This is not very surprising as Linux and FreeBSD stick very closely to their C
  based roots. \cite{freebsd2016}
 
  As we can see, FreeBSD has an even more straightforward memory management system
  than Linux. As surprising as this is, it makes developing services and applications
  for this OS very simple as far as memory management goes.
  \section{Conclusion}

  \clearpage
  \section{Appendix A - Linux Structs}
  All following structs have been pulled from the classroom text. \cite{robertlove2010}
  \begin{lstlisting}

    for future code samples

  \end{lstlisting}

  \section{Appendix B - Windows Structs}
  \begin{lstlisting}

    for future code samples
  \end{lstlisting}
  \section{Appendix C - FreeBSD Structs}
  \begin{lstlisting}
    for future code samples

  \end{lstlisting}

  \section{Bibliography}
  \bibliographystyle{IEEEtran}
  \bibliography{writing_4}

\end{document}
