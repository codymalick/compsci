\documentclass[10pt,letterpaper,onecolumn,draftclsnofoot]{IEEEtran}
\usepackage[margin=0.75in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}
\usepackage{tabu}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  columns=flexible,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}
\begin{titlepage}
  \title{CS 444 - Spring 2016 - Writing Assignment 1}
  \author{Cody Malick\\
  \texttt{malickc@oregonstate.edu}}
  \date{April 21, 2016}
  \maketitle
  \vspace*{4cm}
  \begin{abstract}
      \noindent Understanding how an operating system handles processes, threads,
      and CPU scheduling are important topics for an aspiring kernel developer.
      In this report, we will cover how Linux, Windows, and FreeBSD handle these
      important structures in their respective kernels, and contrast them.
  \end{abstract}
\end{titlepage}

\tableofcontents
\clearpage
\section{Introduction}
This report contains descriptions on how each of the operating systems, Linux,
Windows, and FreeBSD handle processes, threads, and CPU scheduling. A lot can be
learned about the design decisions of the minds behind the operating system by
how they handle these core constructs. We will start by describing how Linux
handles these, as Linux is the focus of this class.

\section{Linux}
  \subsection{Processes}
The first thing that should be defined, is simply what a process is: "A
\textit{process} is a program (object code stored on some media) in the midst of
execution."\cite{robertlove2010} Although the Linux kernel refers to processes
as tasks, in this report (for uniformity) we will only refer to them as processes.

A process in Linux is ultimately born, somewhere up the line, from the
\texttt{init} process. The \texttt{init} is the absolute root of every process
tree on any Linux machine. It has a process ID of 1. All processes are spawned
from either the \texttt{fork()} or \texttt{exec()} function calls. \texttt{Fork()}
creates an exact copy of the calling process as a child of the process, while
\texttt{exec()} loads a new executable into the process space and executes it.
These are the only ways new processes are created in Linux.

Each process has a process descriptor that describes every aspect of
the process, the \texttt{task\_struct}. The \texttt{task\_struct} is contained
in \texttt{<linux/sched.h>}. \texttt{Task\_struct} describes the current state
of the process, the parent process ID, the process ID, exit code, priority, etc.
Everything you could possibly want to know about a process in Linux is in that
struct. I would include it in this report, but it is a very large struct.

Processes have five states, each represented by flags in the
\texttt{task\_struct}:

\begin{description}
  \item \texttt{TASK\_RUNNING}: The process is either running or in a run-queue
  ready to be run (run-queues will be discussed in the CPU scheduling section).
  \item \texttt{TASK\_INTERRUPTIBLE}: the process is sleeping (blocked) waiting
  for a condition to un-block. Once the condition is met, it transitions to
  \texttt{TASK\_RUNNING}.
  \item \texttt{TASK\_UNINTERRRUPTIBLE}: The same state as \texttt{TASK\_INTERRUPTIBLE}
  with the difference being that it does not wake once an interrupt is received.
  \item \texttt{\_TASK\_TRACED}: This flag shows that the process is being traced
  by another process. An example is GDB.
  \item \texttt{\_TASK\_STOPPED}: Process execution has halted and it is not
  possible to start running. This state is a result of a halting interrupt from
  the CPU, or if a debugger sends it a signal.
\end{description}

 \begin{lstlisting}

 \end{lstlisting}

  \subsection{Threads}
As with processes, we will define what a thread is: "Threads of execution, often
shortened to \textit{threads}, are the objects of activity within the process."
\cite{robertlove2010} In Linux, threads are treated fundamentally the same as
processes. The only difference is that they have a shared address space,
filesystem resources, file descriptors, and signal handlers.

  \subsection{CPU Scheduling}

\section{Windows}
  \subsection{Processes}
  \subsection{Threads}
  \subsection{CPU Scheduling}
\section{FreeBSD}
  \subsection{Processes}
  \subsection{Threads}
  \subsection{CPU Scheduling}

\clearpage
\section{Bibliography}

\bibliographystyle{IEEEtran}
\bibliography{writing_1}

\end{document}
